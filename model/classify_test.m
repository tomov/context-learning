function classify_test(method, classifier, trials, runs, sss, mask)
% Test classifier generated by classify_train.m
%

fprintf('classify_test\n');
disp(method)
disp(trials)
disp(runs)
disp(mask)
disp(sss)


% trials = which training trials to use to TEST from each run, e.g. 20:20 or 19:20
% sss = subject indices in the subjects array returned by
%       contextGetSubjectsDirsAndRuns, e.g. getGoodSubjects()
% mask = .nii file name of which mask to use
% method = 'glmnet' or 'patternnet'
% inFilename = .mat file what was output by classify_train (I know it's
%              ghetto; it's so I can run it locally too)
% outFilename = .mat file name where to save the results

model = 60; % the model with the classifier for all trials betas
EXPT = contextExpt();
is_local = 1; % 1 = Momchil's dropbox; 0 = NCF
n_trials_per_run = 24;
%method = 'glmnet'; % patternnet or glmnet
%trials = 20:20;
%sss = getGoodSubjects();
%mask = 'mask.nii';
%inFilename = 'classify_glmnet_fitObj_only_1-19_mask.mat';
%outFilename = 'classify_outputss_fitObj_only_1-19_mask_20.mat';

% which betas to get for each run -- see SPM.xX.name' in any one of the subjects model
% directories
%
betas = [];
for run = runs
    idx = trials + (run - 1) * (n_trials_per_run + 6);
    betas(run,:) = idx;
end

% Get the input vector and labels from the betas
% goal is to infer the targets from the inputs
% assumption is that the targets underlie the inputs
%
labels = containers.Map({'irrelevant', 'modulatory', 'additive'}, ...
                        {[1 0 0], [0 1 0], [0 0 1]});


%load('classify_glmnet_fitObj_only_1-19_mask_scramble_runs.mat'); % load the scrambled run labels
        

inputs = []; % rows = x = observations, cols = voxels / dependent vars
targets = []; % rows = y = observations, cols = indep vars (condition as binary vector)
idx = 0;
%blaaaaa_id = 0;
for subj = sss
    modeldir = fullfile(EXPT.modeldir,['model',num2str(model)],['subj',num2str(subj)]);
   
    for run = runs
        multi = context_create_multi(1, subj, run);
        condition = multi.names{1};
        %blaaaaa_id = blaaaaa_id + 1;
        for i = betas(run,:)
            beta_vec = ccnl_get_beta(EXPT, model, i, mask, [subj]);
            beta_vec(isnan(beta_vec)) = 0;
            
            idx = idx + 1;
            inputs(idx,:) = beta_vec;
            targets(idx,:) = labels(condition);

            % scrambled run labels
            %targets(idx,:) = random_run_labels(blaaaaa_id,:);
        end
    end
end
                        
%load('classify_betas_for_trial_20_mask_scramble_runs.mat');


if strcmp(method, 'patternnet')
    net = classifier;
    
    % patternnet wants column feature vectors. I.e. each data point is a column
    % so we have to rotate it ...
    %
    inputs = inputs'; % ugh MATLAB
    targets = targets';
    
    % Test the Network
    outputs = net(inputs);
    errors = gsubtract(targets,outputs);
    performance = perform(net,targets,outputs);
    
    outFilename = random_string();
    fprintf('SAVING outputs to %s\n', outFilename);
    save(outFilename, 'outputs', 'targets');

    % View the Network
    %view(net)

    % View confusion matrix
    [c,cm,ind,per] = confusion(targets,outputs);
    
    [~, i] = max(targets, [], 1);
    [~, j] = max(outputs, [], 1);
    fprintf('Success rate = %.2f%%\n', 100 * mean(i == j));
    
    % TODO these break for some reason...
    %
    %{
    A = cm';
    B = bsxfun(@rdivide,A,sum(A));
    C = imresize(1 - B, 15, 'method', 'box');
    imshow(C);
    xlabel('Targets');
    ylabel('Outputs');
    %}

elseif strcmp(method, 'glmnet')
    fitObj = classifier;
    
    outputss = glmnetPredict(fitObj, inputs, fitObj.lambda, 'response');
    
    for l = 1:size(outputss, 3) % for all lambdas
        outputs = outputss(:,:,l);
        [~, i] = max(targets, [], 2);
        [~, j] = max(outputs, [], 2);
        fprintf('Success rate for %d (lambda = %.4f) = %.2f%%\n', l, fitObj.lambda(l), 100 * mean(i == j));
    end
    
    outFilename = random_string();
    fprintf('SAVING outputss to %s\n', outFilename);
    save(outFilename, 'outputss', 'targets');
    
else
    assert(false); % no other methods supported
end